<!DOCTYPE html>
<html lang="en"><meta charset="utf-8" />

  <title>Order From Chaos (Part 2): Diffusion for image synthesis explained in code and a little bit of math - Notes</title>


<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="https://mayukhdeb.github.io/notes/css/latex.css" />
<link rel="stylesheet" href="https://mayukhdeb.github.io/notes/css/main.css" />
<link rel="stylesheet" href="https://mayukhdeb.github.io/notes/css/darkmode.css" />
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<meta name="generator" content="Hugo 0.68.3" /><body>






<header>
  <nav class="navbar">
  <div class="nav">
    

    <ul class="nav-links">
      
    </ul>
  </div>
</nav>
  <div class="intro-header">
    <div class="container">
      <div class="post-heading">
        
          <h1>Order From Chaos (Part 2): Diffusion for image synthesis explained in code and a little bit of math</h1>
          
        
      </div>
    </div>
  </div>
</header>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>Dec 25, 2022
  
</span>
      </div>
      <br>
      
    <p><strong>Warning: This post is still being written and is not complete, I just uploaded a draft.</strong></p>
<p>This post is basically what I learned while watching <a href="https://www.youtube.com/watch?v=a4Yfz2FxXiY">this video</a> by DeepFindr.</p>
<p>Diffusion models work by destroying an input gradually until it looks like noise and then recovering the input image from that. The forward process is hardcoded, and the reverse process is trainable.</p>
<p>In the reverse process, the task of the model is to predict the noise that was added in each step to the input image.</p>
<p>We need 3 things for training a diffusion model:</p>
<ol>
<li>A Scheduler that sequentially adds noise</li>
<li>A model that predicts the noise in an image (a U-Net)</li>
<li>A time-step encoding component</li>
</ol>
<h2 id="the-forward-process">The forward process</h2>

<p>
In simple words, we iteratively add noise into the image where the amount of noise added per step is dependent on a parameter \(\beta\)
</p>

<p>In fancy math terms, this is how we perform the markov process:</p>
<p>$$
q(x_{1:T}|x_0) = \prod_{t=1}^{t=T}q(x_t|x_{t-1})
$$</p>

<p>
\(x_{1:T}\) =  set of samples where every subsequent item is noisier starting from the orignial image. \(x_1\) is the input image after adding some noise for the first time (i.e the first step) and \(x_T\) is the most noisy sample.
</p>

<p>
\(\prod_{t=1}^{t=T}q(x_t|x_{t-1})\) is the product of the noise samples for all values of \(t\) starting from 1 to \(T\)
</p>

<p><strong>Diving deeper into each noise sample \(q(x_t|x_{t-1})\)</strong></p>
<p>First, let&rsquo;s see how it&rsquo;s defined:</p>
<p>$$
q(x_t|x_{t-1}) = N(x_t;\sqrt{1-\beta_t}x_{t-1}, \beta_tI)
$$</p>
<ul>
<li>

<p>
\(\beta_t\) determines the variance of the noise to be added in each step into the image. 
</p>

</li>
<li>

<p>
\(x_{t-1}\) is the previous less noisy image. 
</p>

</li>
<li>

<p>
\(\sqrt{1 - \beta_t}\) scales the mean of the noise to be added. Thus one can say that the mean of our distribution is \(\sqrt{1-\beta_t}\) multiplied by \(x_{t-1}\) (for each pixel).
</p>

</li>
<li>

<p>
\(I\) is the Identity
</p>

</li>
</ul>

<p>
The sequence of such betas \(\beta_1\), \(\beta_2\)... \(\beta_t\) is known as the variance schedule. They determine how much noise we'd want to add in each of the time steps.
</p>

<p><strong>Diving deeper into \(\beta\)</strong></p>
<p>Let us imagine for a second that we have an image with a single pixel and then try to understand what then equation above means:</p>

<p>
\(q(x|x_{t-1})\) = the value of the next pixel (q of \(x\) given \(x_{t-1}\))
</p>

<center>
<img src = 'https://user-images.githubusercontent.com/53133634/209522028-ad0081b5-c233-4039-8d80-8a399f94c7a3.png' width = "40%">
Image taken from DeepFindr's video[1] at 8m47s.
</center>
<ul>
<li>

<p>
\(\mu\) is the mean of the dstribution from which we would sample the next pixel
</p>

</li>
<li>

<p>
\(\sigma\) is the variance.
</p>

</li>
</ul>

So increasing \(\beta\) would result in the distribution shifting to the left and also becoming more flattened (w i d e r). Kind of like the blue distribution shown below.

<center>
<img src = 'https://user-images.githubusercontent.com/53133634/209523096-53d22a91-6c9a-4af7-9c74-b683b39b9749.png' width = "40%">
Image taken from DeepFindr's video[1] at 9m28s.
</center>
<p>Beta determines how fast we converge towards a mean of zero which is basically a standard gaussian distribution. Beta increases linearly with each time step (from like <code>0.0001</code> to <code>0.02</code> in 200 steps)</p>
<h3 id="speeding-things-up">Speeding things up</h3>

<p>
The neat thing about gaussians is that the sum of gaussians is also a gaussian. Which means it's pretty easy to pre-compute the noisy image at forward time-step \(t\)
</p>

<p>
Now for convenience, we would make a new variable \(\alpha_t = 1 - \beta_t\). Since beta was being scaled up, alpha would be scaled down on each step. You can think of alpha as the variable which determines how much information is conserved from the previous image in each time step.
</p>
<p>
The nice part is that we can just take the cumulative products of alpha (\(\bar{\alpha_t}\)) and then we can compute the image at a forward step \(t\) without having to calculate all the way until step \(t-1\) first. This way, we can re-define the noise sampling as follows:
</p>

<p>$$
q(x_t|x_{t_0}) = N(x_t;\sqrt{\bar{\alpha_t}}x_{0}, (1 - \bar{\alpha_t})I)
$$</p>

Notice how this function is dependend only on \(x_0\) and not on \(x_t\) but it computes the noisy pixel value at time step \(t\).

<h3 id="finally-some-code">Finally, some code</h3>
<p>I&rsquo;ll try to explain things line-by-line:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> torch
<span style="color:#f92672">import</span> torch.nn.functional <span style="color:#f92672">as</span> F

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">linear_beta_schedule</span>(timesteps, start<span style="color:#f92672">=</span><span style="color:#ae81ff">0.0001</span>, end<span style="color:#f92672">=</span><span style="color:#ae81ff">0.02</span>):

    <span style="color:#75715e">## Interpolates between 2 values with a pre-defined number of timesteps. </span>
    <span style="color:#75715e">## Returns a list of Betas</span>
    <span style="color:#66d9ef">return</span> torch<span style="color:#f92672">.</span>linspace(start, end, timesteps)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_index_from_list</span>(vals, t, x_shape):
    <span style="color:#e6db74">&#34;&#34;&#34; 
</span><span style="color:#e6db74">    Returns a specific index t of a passed list of values vals
</span><span style="color:#e6db74">    while considering the batch dimension.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    batch_size <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]
    out <span style="color:#f92672">=</span> vals<span style="color:#f92672">.</span>gather(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, t<span style="color:#f92672">.</span>cpu())
    <span style="color:#66d9ef">return</span> out<span style="color:#f92672">.</span>reshape(batch_size, <span style="color:#f92672">*</span>((<span style="color:#ae81ff">1</span>,) <span style="color:#f92672">*</span> (len(x_shape) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)))<span style="color:#f92672">.</span>to(t<span style="color:#f92672">.</span>device)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward_diffusion_sample</span>(x_0, t, device<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cpu&#34;</span>):
    <span style="color:#75715e">## takes the input image and the timestep number t as input</span>
    <span style="color:#75715e">## and returns it&#39;s noisy version at timestep t</span>
    noise <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>randn_like(x_0)
    sqrt_alphas_cumprod_t <span style="color:#f92672">=</span> get_index_from_list(sqrt_alphas_cumprod, t, x_0<span style="color:#f92672">.</span>shape)
    sqrt_one_minus_alphas_cumprod_t <span style="color:#f92672">=</span> get_index_from_list(
        sqrt_one_minus_alphas_cumprod, t, x_0<span style="color:#f92672">.</span>shape
    )
    <span style="color:#75715e"># mean + variance</span>
    <span style="color:#66d9ef">return</span> sqrt_alphas_cumprod_t<span style="color:#f92672">.</span>to(device) <span style="color:#f92672">*</span> x_0<span style="color:#f92672">.</span>to(device) \
    <span style="color:#f92672">+</span> sqrt_one_minus_alphas_cumprod_t<span style="color:#f92672">.</span>to(device) <span style="color:#f92672">*</span> noise<span style="color:#f92672">.</span>to(device), noise<span style="color:#f92672">.</span>to(device)

</code></pre></div><p>The last line in the above snippet is equivalent to:</p>
<p>$$
x_t = \sqrt{\bar{\alpha_t}}x_0 + \sqrt{1-\bar{\alpha_t}}\epsilon
$$</p>

Where \(\epsilon\) is the noise added into the image.

<p>Then, we pre-compute the variables for convenience:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">alphas <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.</span> <span style="color:#f92672">-</span> betas
alphas_cumprod <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cumprod(alphas, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
alphas_cumprod_prev <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>pad(alphas_cumprod[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>), value<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>)
sqrt_recip_alphas <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>sqrt(<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> alphas)
sqrt_alphas_cumprod <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>sqrt(alphas_cumprod)
sqrt_one_minus_alphas_cumprod <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>sqrt(<span style="color:#ae81ff">1.</span> <span style="color:#f92672">-</span> alphas_cumprod)
posterior_variance <span style="color:#f92672">=</span> betas <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1.</span> <span style="color:#f92672">-</span> alphas_cumprod_prev) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1.</span> <span style="color:#f92672">-</span> alphas_cumprod)
</code></pre></div><h2 id="the-neural-network">The Neural network</h2>
<p>The authors proposed to use a a U-Net, which is an image-to-image model. Here the input is the noisy image, and the output is the &ldquo;noise&rdquo; predicted by the model.</p>

So if we have an input \(x_t = x0 + \epsilon\) then the model's output would ideally be \(\epsilon\) or something close to it.

<h2 id="encoding-time-steps">Encoding time steps</h2>
<p>Note that we also have to let the model know in which timestep the input image is, this is done with the help of positional embeddings.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SinusoidalPositionEmbeddings</span>(nn<span style="color:#f92672">.</span>Module):
    <span style="color:#66d9ef">def</span> __init__(self, dim):
        super()<span style="color:#f92672">.</span>__init__()
        self<span style="color:#f92672">.</span>dim <span style="color:#f92672">=</span> dim

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, time):
        device <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>device
        half_dim <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dim <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
        embeddings <span style="color:#f92672">=</span> math<span style="color:#f92672">.</span>log(<span style="color:#ae81ff">10000</span>) <span style="color:#f92672">/</span> (half_dim <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        embeddings <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>exp(torch<span style="color:#f92672">.</span>arange(half_dim, device<span style="color:#f92672">=</span>device) <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>embeddings)
        embeddings <span style="color:#f92672">=</span> time[:, None] <span style="color:#f92672">*</span> embeddings[None, :]
        embeddings <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cat((embeddings<span style="color:#f92672">.</span>sin(), embeddings<span style="color:#f92672">.</span>cos()), dim<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> embeddings
</code></pre></div><p><strong>Intuition behind <code>SinusoidalPositionEmbeddings</code></strong></p>
<p>(btw this also applies to transformers in general)</p>
<p>To understand this, first let&rsquo;s take a look at how binary numbers work. You might be able to notice here that the right-most bit (red) oscillates between 0 and 1 the fastest and the subsequent ones (blue, green, yellow) oscillate in slower and slower rates.</p>
<center>
<img src = "https://user-images.githubusercontent.com/53133634/209769905-70663f7f-aa2c-4ee6-9fd3-590f4245b089.png" width = "50%">
</center>
<p>Now if we use these values as positional encodings, the last 2 bits are good at giving fine-grained relative positions between 2 positions which are close to each other. While the larger bits are good at encoding the position at a larger scale. This way, the model would get both the overall location of each token but would also be able to distinguish between tokens which are very close to each other.</p>
<p>But in real life, binary numbers take up lots of space. So instead we use the something fancier: Sinusoids.</p>
<center>
<img src = "https://user-images.githubusercontent.com/53133634/209771097-1e970289-bfbc-4624-bad6-639f98aac172.png" width = "100%">
</center>
<p>In the figure above, you can see how the first column (left) oscillates the fastest and every column after that one oscillates slower and slower. These are sinusoidal positional embeddings with a depth of 128.</p>
<h2 id="combining-time-step-encoding-with-image-data">Combining time-step encoding with image data</h2>
<p>I will not go into depth about the U-Net architecture itself, because it can be and has been replaced with other models for diffusion. You can just think of it as a model which takes an image as an input and is supposed to predict the noise in the input (which gets subtracted).</p>
<p>The important thing to note here is that we do not concatenate the time embeddings into the data, instead we add it right after passing the input through the first conv layer of a U-Net block.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Block</span>(nn<span style="color:#f92672">.</span>Module):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A single building block from the U-Net
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">def</span> __init__(self, in_ch, out_ch, time_emb_dim, up<span style="color:#f92672">=</span>False):
        super()<span style="color:#f92672">.</span>__init__()
        self<span style="color:#f92672">.</span>time_mlp <span style="color:#f92672">=</span>  nn<span style="color:#f92672">.</span>Linear(time_emb_dim, out_ch)
        <span style="color:#66d9ef">if</span> up:
            self<span style="color:#f92672">.</span>conv1 <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Conv2d(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>in_ch, out_ch, <span style="color:#ae81ff">3</span>, padding<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
            self<span style="color:#f92672">.</span>transform <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>ConvTranspose2d(out_ch, out_ch, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">else</span>:
            self<span style="color:#f92672">.</span>conv1 <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Conv2d(in_ch, out_ch, <span style="color:#ae81ff">3</span>, padding<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
            self<span style="color:#f92672">.</span>transform <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Conv2d(out_ch, out_ch, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>)
        self<span style="color:#f92672">.</span>conv2 <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Conv2d(out_ch, out_ch, <span style="color:#ae81ff">3</span>, padding<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
        self<span style="color:#f92672">.</span>bnorm1 <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>BatchNorm2d(out_ch)
        self<span style="color:#f92672">.</span>bnorm2 <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>BatchNorm2d(out_ch)
        self<span style="color:#f92672">.</span>relu  <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>ReLU()
        
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x, t, ):
        <span style="color:#75715e"># First Conv</span>
        h <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bnorm1(self<span style="color:#f92672">.</span>relu(self<span style="color:#f92672">.</span>conv1(x)))
        <span style="color:#75715e"># Time embedding</span>
        time_emb <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>relu(self<span style="color:#f92672">.</span>time_mlp(t))
        <span style="color:#75715e"># Extend last 2 dimensions</span>
        time_emb <span style="color:#f92672">=</span> time_emb[(<span style="color:#f92672">...</span>, ) <span style="color:#f92672">+</span> (None, ) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>]
        <span style="color:#e6db74">&#39;&#39;&#39;
</span><span style="color:#e6db74">        This is where we add in the time embedding
</span><span style="color:#e6db74">        combines time step and image information
</span><span style="color:#e6db74">        &#39;&#39;&#39;</span>
        h <span style="color:#f92672">=</span> h <span style="color:#f92672">+</span> time_emb
        <span style="color:#75715e"># Second Conv</span>
        h <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bnorm2(self<span style="color:#f92672">.</span>relu(self<span style="color:#f92672">.</span>conv2(h)))
        <span style="color:#75715e"># Down or Upsample</span>
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>transform(h)
</code></pre></div><h2 id="loss-function">Loss function</h2>
<p>The loss function is basically the L1 loss on the predicted noise v/s the original noise:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_loss</span>(model, x_0, t):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    model: U-Net model through which we pass the image
</span><span style="color:#e6db74">    x_0: original input image
</span><span style="color:#e6db74">    t: a specific time step
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">    functions within:
</span><span style="color:#e6db74">        * forward_diffusion_sample: returns the noisy version of the original image and the noise that was last added for the time step t
</span><span style="color:#e6db74">        * model.__call__: takes as input the noisy image and the time step, tries to predict the noise that was last added for the time step t
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    x_noisy, noise <span style="color:#f92672">=</span> forward_diffusion_sample(x_0, t, device)
    noise_pred <span style="color:#f92672">=</span> model(x_noisy, t)
    <span style="color:#66d9ef">return</span> F<span style="color:#f92672">.</span>l1_loss(noise, noise_pred)
</code></pre></div><h2 id="sampling">Sampling</h2>
<p>TODO: explain this</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@torch.no_grad</span>()
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sample_timestep</span>(x, t):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Calls the model to predict the noise in the image and returns 
</span><span style="color:#e6db74">    the denoised image. 
</span><span style="color:#e6db74">    Applies noise to this image, if we are not in the last step yet.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    betas_t <span style="color:#f92672">=</span> get_index_from_list(betas, t, x<span style="color:#f92672">.</span>shape)
    sqrt_one_minus_alphas_cumprod_t <span style="color:#f92672">=</span> get_index_from_list(
        sqrt_one_minus_alphas_cumprod, t, x<span style="color:#f92672">.</span>shape
    )
    sqrt_recip_alphas_t <span style="color:#f92672">=</span> get_index_from_list(sqrt_recip_alphas, t, x<span style="color:#f92672">.</span>shape)
    
    <span style="color:#75715e"># Call model (current image - noise prediction)</span>
    model_mean <span style="color:#f92672">=</span> sqrt_recip_alphas_t <span style="color:#f92672">*</span> (
        x <span style="color:#f92672">-</span> betas_t <span style="color:#f92672">*</span> model(x, t) <span style="color:#f92672">/</span> sqrt_one_minus_alphas_cumprod_t
    )
    posterior_variance_t <span style="color:#f92672">=</span> get_index_from_list(posterior_variance, t, x<span style="color:#f92672">.</span>shape)
    
    <span style="color:#66d9ef">if</span> t <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">return</span> model_mean
    <span style="color:#66d9ef">else</span>:
        noise <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>randn_like(x)
        <span style="color:#66d9ef">return</span> model_mean <span style="color:#f92672">+</span> torch<span style="color:#f92672">.</span>sqrt(posterior_variance_t) <span style="color:#f92672">*</span> noise 
</code></pre></div><h2 id="references">References</h2>
<p>[1] - <a href="https://www.youtube.com/watch?v=a4Yfz2FxXiY">DeepFindr&rsquo;s video</a></p>



      
        <div class="blog-tags">
          
            <a href="https://mayukhdeb.github.io/notes//tags/paper/">paper</a>&nbsp;
          
        </div>
      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;/&nbsp;Theme&nbsp;<a href="https://github.com/HelloRusk/HugoTeX">HugoTeX</a>
        <br>
        <a href="https://mayukhdeb.github.io/notes/about">Mayukh Deb</a>
        &copy;
        2022
      </p>
  </div>
</footer></body>
</html>
